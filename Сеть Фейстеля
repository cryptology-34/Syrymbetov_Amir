import hashlib


class FeistelNetwork:
    def __init__(self, key, rounds=16):
        self.key = key
        self.rounds = rounds
        self.position = 0
        self.block_size = 16  # 128 бит = 16 байт

    def _reset_position(self):
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def _f_function(self, right_block, round_key):
        """F-функция для правой половины блока (8 байт)"""
        block_bytes = right_block.to_bytes(8, 'big')  # 8 байт вместо 4
        
        # XOR с ключом раунда и хешируем
        mixed = bytes([block_bytes[i] ^ round_key[i % len(round_key)] for i in range(len(block_bytes))])
        result = hashlib.sha256(mixed).digest()
        
        # Возвращаем первые 8 байт как int
        return int.from_bytes(result[:8], 'big')

    def _split_blocks(self, data):
        """Разделяем данные на блоки по 16 байт (128 бит)"""
        blocks = []
        for i in range(0, len(data), self.block_size):
            block = data[i:i + self.block_size]
            # Дополняем последний блок если нужно
            if len(block) < self.block_size:
                block = block + b'\x00' * (self.block_size - len(block))
            blocks.append(block)
        return blocks

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
            
        self._reset_position()
        blocks = self._split_blocks(data)
        encrypted_blocks = []
        
        for block in blocks:
            # Разделяем блок на две части по 8 байт каждая
            left = int.from_bytes(block[:8], 'big')    # 8 байт
            right = int.from_bytes(block[8:], 'big')   # 8 байт
            
            # Генерируем ключи для всех раундов (8 байт на раунд)
            round_keys = self._key_stream(self.rounds * 8)
            
            # Выполняем раунды Фейстеля
            for round_num in range(self.rounds):
                round_key = round_keys[round_num*8:(round_num+1)*8]
                
                temp = right
                f_result = self._f_function(right, round_key)
                right = left ^ f_result
                left = temp
            
            # Объединяем финальные блоки
            encrypted_block = left.to_bytes(8, 'big') + right.to_bytes(8, 'big')
            encrypted_blocks.append(encrypted_block)
        
        return b''.join(encrypted_blocks)

    def decrypt(self, encrypted_data):
        self._reset_position()
        blocks = self._split_blocks(encrypted_data)
        decrypted_blocks = []
        
        for block in blocks:
            left = int.from_bytes(block[:8], 'big')
            right = int.from_bytes(block[8:], 'big')
            
            round_keys = self._key_stream(self.rounds * 8)
            
            for round_num in range(self.rounds-1, -1, -1):
                round_key = round_keys[round_num*8:(round_num+1)*8]
                
                temp = left
                f_result = self._f_function(left, round_key)
                left = right ^ f_result
                right = temp
            
            decrypted_block = left.to_bytes(8, 'big') + right.to_bytes(8, 'big')
            decrypted_blocks.append(decrypted_block)
        
        result = b''.join(decrypted_blocks)
        # Убираем дополняющие нули
        return result.rstrip(b'\x00')

    def decrypt(self, encrypted_data):
        iv = encrypted_data[:self.block_size]
        encrypted_blocks = [encrypted_data[i:i + self.block_size]
                            for i in range(self.block_size, len(encrypted_data), self.block_size)]

        decrypted_blocks = []
        prev_block = iv

        for block in encrypted_blocks:
            decrypted_block = self.cipher.decrypt(block)
            xored = bytes([decrypted_block[i] ^ prev_block[i] for i in range(self.block_size)])
            decrypted_blocks.append(xored)
            prev_block = block

        # Убираем паддинг
        padding_length = decrypted_blocks[-1][-1]
        if padding_length <= self.block_size:
            result = b''.join(decrypted_blocks)
            return result[:-padding_length]
        else:
            return b''.join(decrypted_blocks)


class StreamCipher:
    def __init__(self, key):
        self.key = key
        self.position = 0

    def _reset_position(self):
        """Сброс позиции для начала нового шифрования/дешифрования"""
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
        self._reset_position()  # Сбрасываем позицию
        key_stream = self._key_stream(len(data))
        encrypted = bytes([data[i] ^ key_stream[i] for i in range(len(data))])
        return encrypted

    def decrypt(self, encrypted_data):
        self._reset_position()  # Сбрасываем позицию
        return self.encrypt(encrypted_data)


def interactive_cipher():
    print("=== Сравнение поточного шифра и сети Фейстеля ===")

    while True:
        print("\nВыберите алгоритм:")
        print("1. Поточный шифр (XOR)")
        print("2. Сеть Фейстеля (блочный)")
        print("3. Тестирование обоих алгоритмов")
        print("4. Выйти")

        algo_choice = input("Ваш выбор (1-4): ").strip()

        if algo_choice == '4':
            print("Выход...")
            break
        elif algo_choice == '3':
            test_both_algorithms()
            continue
        elif algo_choice not in ['1', '2']:
            print("Неверный выбор алгоритма!")
            continue

        mode = input("Вы хотите зашифровать (e) или расшифровать (d)? ").strip().lower()

        if mode not in ['e', 'd']:
            print("Неверный выбор режима!")
            continue

        key_input = input("Введите ключ: ")
        if not key_input:
            print("Ключ не может быть пустым!")
            continue
        key = key_input.encode()

        if algo_choice == '1':
            cipher = StreamCipher(key)
            algo_name = "поточный шифр"
        else:
            rounds_input = input("Введите количество раундов (по умолчанию 16): ").strip()
            rounds = int(rounds_input) if rounds_input else 16
            cipher = FeistelNetwork(key, rounds)
            algo_name = f"сеть Фейстеля ({rounds} раундов)"

        if mode == 'e':
            message = input("Введите сообщение для шифрования: ")
            if not message:
                print("Сообщение не может быть пустым!")
                continue

            print(f"\nШифруем с помощью {algo_name}...")
            encrypted = cipher.encrypt(message)
            print(f"Зашифрованное (hex): {encrypted.hex()}")
            print(f"Длина: {len(encrypted)} байт")

        else:  # mode == 'd'
            hex_data = input("Введите зашифрованный текст в hex: ").strip()
            if not hex_data:
                print("Данные не могут быть пустыми!")
                continue

            try:
                encrypted = bytes.fromhex(hex_data)
                print(f"\nДешифруем с помощью {algo_name}...")
                decrypted = cipher.decrypt(encrypted)

                # Для сети Фейстеля убираем дополняющие нули
                if algo_choice == '2':
                    decrypted = decrypted.rstrip(b'\x00')

                print(f"Расшифрованное сообщение: {decrypted.decode(errors='replace')}")

            except ValueError as e:
                print(f"Ошибка: неверный hex формат! {e}")
            except Exception as e:
                print(f"Ошибка при дешифровании: {e}")


def test_both_algorithms():
    """Тестирование обоих алгоритмов - теперь с вводом сообщения"""
    print("\n" + "=" * 50)
    print("ТЕСТИРОВАНИЕ АЛГОРИТМОВ")
    print("=" * 50)

    # Теперь сообщение вводится пользователем!
    message = input("Введите тестовое сообщение: ")
    if not message:
        print("Сообщение не может быть пустым!")
        return

    key_input = input("Введите ключ для теста (или нажмите Enter для ключа по умолчанию b'test_key'): ")
    key = key_input.encode() if key_input else b"test_key"

    rounds_input = input("Введите количество раундов для Фейстеля (по умолчанию 8): ")
    rounds = int(rounds_input) if rounds_input else 8

    print(f"\n--- Тестовые данные ---")
    print(f"Сообщение: '{message}'")
    print(f"Длина сообщения: {len(message)} байт")
    print(f"Ключ: {key}")
    print(f"Раунды Фейстеля: {rounds}")

    # Тестируем поточный шифр
    print(f"\n--- Поточный шифр ---")
    stream_cipher = StreamCipher(key)
    stream_encrypted = stream_cipher.encrypt(message)
    stream_decrypted = stream_cipher.decrypt(stream_encrypted)
    stream_success = stream_decrypted.decode() == message

    print(f"Результат: {'✓ УСПЕХ' if stream_success else '✗ ОШИБКА'}")
    print(f"Зашифрованные данные (hex): {stream_encrypted.hex()}")

    # Тестируем сеть Фейстеля
    print(f"\n--- Сеть Фейстеля ---")
    feistel = FeistelNetwork(key, rounds)
    feistel_encrypted = feistel.encrypt(message)
    feistel_decrypted = feistel.decrypt(feistel_encrypted)
    feistel_clean = feistel_decrypted.rstrip(b'\x00')

    try:
        feistel_decoded = feistel_clean.decode()
        feistel_success = feistel_decoded == message
        print(f"Результат: {'✓ УСПЕХ' if feistel_success else '✗ ОШИБКА'}")
        if not feistel_success:
            print(f"  Ожидалось: '{message}'")
            print(f"  Получено: '{feistel_decoded}'")
    except Exception as e:
        print(f"Результат: ✗ ОШИБКА при декодировании")
        print(f"  Ошибка: {e}")

    print(f"Зашифрованные данные (hex): {feistel_encrypted.hex()}")
    print(f"Размер после шифрования: {len(feistel_encrypted)} байт")


if __name__ == "__main__":
    interactive_cipher()
