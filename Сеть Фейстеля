import hashlib


class CBCMode:
    """Реализация режима CBC для 128-битных блоков"""

    def __init__(self, cipher, iv=None):
        self.cipher = cipher
        self.block_size = 16  # 128 бит
        self.iv = iv or os.urandom(self.block_size)

    def encrypt(self, data):
        # Дополняем данные до размера блока
        padding_length = self.block_size - (len(data) % self.block_size)
        if padding_length == 0:
            padding_length = self.block_size
        data = data + bytes([padding_length] * padding_length)

        blocks = [data[i:i + self.block_size] for i in range(0, len(data), self.block_size)]

        encrypted_blocks = []
        prev_block = self.iv

        for block in blocks:
            xored = bytes([block[i] ^ prev_block[i] for i in range(self.block_size)])
            encrypted_block = self.cipher.encrypt(xored)
            encrypted_blocks.append(encrypted_block)
            prev_block = encrypted_block

        return self.iv + b''.join(encrypted_blocks)

    def decrypt(self, encrypted_data):
        iv = encrypted_data[:self.block_size]
        encrypted_blocks = [encrypted_data[i:i + self.block_size]
                            for i in range(self.block_size, len(encrypted_data), self.block_size)]

        decrypted_blocks = []
        prev_block = iv

        for block in encrypted_blocks:
            decrypted_block = self.cipher.decrypt(block)
            xored = bytes([decrypted_block[i] ^ prev_block[i] for i in range(self.block_size)])
            decrypted_blocks.append(xored)
            prev_block = block

        # Убираем паддинг
        padding_length = decrypted_blocks[-1][-1]
        if padding_length <= self.block_size:
            result = b''.join(decrypted_blocks)
            return result[:-padding_length]
        else:
            return b''.join(decrypted_blocks)


class StreamCipher:
    def __init__(self, key):
        self.key = key
        self.position = 0

    def _reset_position(self):
        """Сброс позиции для начала нового шифрования/дешифрования"""
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
        self._reset_position()  # Сбрасываем позицию
        key_stream = self._key_stream(len(data))
        encrypted = bytes([data[i] ^ key_stream[i] for i in range(len(data))])
        return encrypted

    def decrypt(self, encrypted_data):
        self._reset_position()  # Сбрасываем позицию
        return self.encrypt(encrypted_data)


def interactive_cipher():
    print("=== Сравнение поточного шифра и сети Фейстеля ===")

    while True:
        print("\nВыберите алгоритм:")
        print("1. Поточный шифр (XOR)")
        print("2. Сеть Фейстеля (блочный)")
        print("3. Тестирование обоих алгоритмов")
        print("4. Выйти")

        algo_choice = input("Ваш выбор (1-4): ").strip()

        if algo_choice == '4':
            print("Выход...")
            break
        elif algo_choice == '3':
            test_both_algorithms()
            continue
        elif algo_choice not in ['1', '2']:
            print("Неверный выбор алгоритма!")
            continue

        mode = input("Вы хотите зашифровать (e) или расшифровать (d)? ").strip().lower()

        if mode not in ['e', 'd']:
            print("Неверный выбор режима!")
            continue

        key_input = input("Введите ключ: ")
        if not key_input:
            print("Ключ не может быть пустым!")
            continue
        key = key_input.encode()

        if algo_choice == '1':
            cipher = StreamCipher(key)
            algo_name = "поточный шифр"
        else:
            rounds_input = input("Введите количество раундов (по умолчанию 16): ").strip()
            rounds = int(rounds_input) if rounds_input else 16
            cipher = FeistelNetwork(key, rounds)
            algo_name = f"сеть Фейстеля ({rounds} раундов)"

        if mode == 'e':
            message = input("Введите сообщение для шифрования: ")
            if not message:
                print("Сообщение не может быть пустым!")
                continue

            print(f"\nШифруем с помощью {algo_name}...")
            encrypted = cipher.encrypt(message)
            print(f"Зашифрованное (hex): {encrypted.hex()}")
            print(f"Длина: {len(encrypted)} байт")

        else:  # mode == 'd'
            hex_data = input("Введите зашифрованный текст в hex: ").strip()
            if not hex_data:
                print("Данные не могут быть пустыми!")
                continue

            try:
                encrypted = bytes.fromhex(hex_data)
                print(f"\nДешифруем с помощью {algo_name}...")
                decrypted = cipher.decrypt(encrypted)

                # Для сети Фейстеля убираем дополняющие нули
                if algo_choice == '2':
                    decrypted = decrypted.rstrip(b'\x00')

                print(f"Расшифрованное сообщение: {decrypted.decode(errors='replace')}")

            except ValueError as e:
                print(f"Ошибка: неверный hex формат! {e}")
            except Exception as e:
                print(f"Ошибка при дешифровании: {e}")


def test_both_algorithms():
    """Тестирование обоих алгоритмов - теперь с вводом сообщения"""
    print("\n" + "=" * 50)
    print("ТЕСТИРОВАНИЕ АЛГОРИТМОВ")
    print("=" * 50)

    # Теперь сообщение вводится пользователем!
    message = input("Введите тестовое сообщение: ")
    if not message:
        print("Сообщение не может быть пустым!")
        return

    key_input = input("Введите ключ для теста (или нажмите Enter для ключа по умолчанию b'test_key'): ")
    key = key_input.encode() if key_input else b"test_key"

    rounds_input = input("Введите количество раундов для Фейстеля (по умолчанию 8): ")
    rounds = int(rounds_input) if rounds_input else 8

    print(f"\n--- Тестовые данные ---")
    print(f"Сообщение: '{message}'")
    print(f"Длина сообщения: {len(message)} байт")
    print(f"Ключ: {key}")
    print(f"Раунды Фейстеля: {rounds}")

    # Тестируем поточный шифр
    print(f"\n--- Поточный шифр ---")
    stream_cipher = StreamCipher(key)
    stream_encrypted = stream_cipher.encrypt(message)
    stream_decrypted = stream_cipher.decrypt(stream_encrypted)
    stream_success = stream_decrypted.decode() == message

    print(f"Результат: {'✓ УСПЕХ' if stream_success else '✗ ОШИБКА'}")
    print(f"Зашифрованные данные (hex): {stream_encrypted.hex()}")

    # Тестируем сеть Фейстеля
    print(f"\n--- Сеть Фейстеля ---")
    feistel = FeistelNetwork(key, rounds)
    feistel_encrypted = feistel.encrypt(message)
    feistel_decrypted = feistel.decrypt(feistel_encrypted)
    feistel_clean = feistel_decrypted.rstrip(b'\x00')

    try:
        feistel_decoded = feistel_clean.decode()
        feistel_success = feistel_decoded == message
        print(f"Результат: {'✓ УСПЕХ' if feistel_success else '✗ ОШИБКА'}")
        if not feistel_success:
            print(f"  Ожидалось: '{message}'")
            print(f"  Получено: '{feistel_decoded}'")
    except Exception as e:
        print(f"Результат: ✗ ОШИБКА при декодировании")
        print(f"  Ошибка: {e}")

    print(f"Зашифрованные данные (hex): {feistel_encrypted.hex()}")
    print(f"Размер после шифрования: {len(feistel_encrypted)} байт")


if __name__ == "__main__":
    interactive_cipher()
