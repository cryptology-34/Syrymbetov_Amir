import hashlib

class SPN:
    def __init__(self, key, rounds=4, block_size=16):
        self.key = key
        self.rounds = rounds
        self.block_size = block_size  # 16 байт = 128 бит
        self.position = 0

    def _reset_position(self):
        """Сброс позиции для начала нового шифрования/дешифрования"""
        self.position = 0

    def _key_stream(self, length):
        """Генератор ключевого потока на основе SHA-256"""
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def _generate_round_keys(self):
        """Генерация ключей для всех раундов"""
        total_keys_needed = (self.rounds + 1) * self.block_size
        key_material = self._key_stream(total_keys_needed)
        
        round_keys = []
        for i in range(self.rounds + 1):
            start = i * self.block_size
            end = start + self.block_size
            round_keys.append(key_material[start:end])
        
        return round_keys

    def _s_box(self, byte):
        """S-бокс: замена байта по нелинейной таблице"""
        # Простой S-бокс на основе SHA-256
        s_box_data = hashlib.sha256(b's_box_' + bytes([byte])).digest()
        return s_box_data[0]

    def _inverse_s_box(self, byte):
        """Обратный S-бокс: найти оригинальный байт"""
        # Поиск обратного значения (медленно, но для демонстрации подходит)
        for i in range(256):
            if self._s_box(i) == byte:
                return i
        return byte

    def _substitute_bytes(self, data):
        """Применение S-бокса ко всем байтам блока"""
        return bytes([self._s_box(b) for b in data])

    def _inverse_substitute_bytes(self, data):
        """Применение обратного S-бокса ко всем байтам блока"""
        return bytes([self._inverse_s_box(b) for b in data])

    def _permute_bits(self, data):
        """P-бокс: перестановка битов в блоке"""
        # Преобразуем байты в биты
        bits = []
        for byte in data:
            bits.extend([(byte >> i) & 1 for i in range(7, -1, -1)])
        
        # Перестановка битов (простая циклическая перестановка)
        permuted_bits = bits[4:] + bits[:4]
        
        # Преобразуем обратно в байты
        result = bytearray()
        for i in range(0, len(permuted_bits), 8):
            byte = 0
            for j in range(8):
                if i + j < len(permuted_bits):
                    byte = (byte << 1) | permuted_bits[i + j]
            result.append(byte)
        
        return bytes(result)

    def _inverse_permute_bits(self, data):
        """Обратная перестановка битов"""
        bits = []
        for byte in data:
            bits.extend([(byte >> i) & 1 for i in range(7, -1, -1)])
        
        # Обратная перестановка
        inverse_permuted_bits = bits[-4:] + bits[:-4]
        
        result = bytearray()
        for i in range(0, len(inverse_permuted_bits), 8):
            byte = 0
            for j in range(8):
                if i + j < len(inverse_permuted_bits):
                    byte = (byte << 1) | inverse_permuted_bits[i + j]
            result.append(byte)
        
        return bytes(result)

    def _split_blocks(self, data):
        """Разделяем данные на блоки фиксированного размера"""
        blocks = []
        for i in range(0, len(data), self.block_size):
            block = data[i:i + self.block_size]
            # Дополняем последний блок если нужно
            if len(block) < self.block_size:
                block = block + b'\x00' * (self.block_size - len(block))
            blocks.append(block)
        return blocks

    def encrypt(self, data):
        """Шифрование с использованием SPN"""
        if isinstance(data, str):
            data = data.encode()
            
        self._reset_position()
        round_keys = self._generate_round_keys()
        blocks = self._split_blocks(data)
        encrypted_blocks = []
        
        for block in blocks:
            current_state = block
            
            # Основные раунды
            for round_num in range(self.rounds):
                # XOR с ключом раунда
                current_state = bytes([current_state[i] ^ round_keys[round_num][i] 
                                     for i in range(len(current_state))])
                
                # Замена байтов (S-бокс)
                current_state = self._substitute_bytes(current_state)
                
                # Перестановка битов (P-бокс), кроме последнего раунда
                if round_num < self.rounds - 1:
                    current_state = self._permute_bits(current_state)
            
            # Финальный XOR с последним ключом
            current_state = bytes([current_state[i] ^ round_keys[self.rounds][i] 
                                 for i in range(len(current_state))])
            
            encrypted_blocks.append(current_state)
        
        return b''.join(encrypted_blocks)

    def decrypt(self, encrypted_data):
        """Дешифрование с использованием SPN"""
        self._reset_position()
        round_keys = self._generate_round_keys()
        blocks = self._split_blocks(encrypted_data)
        decrypted_blocks = []
        
        for block in blocks:
            current_state = block
            
            # Обратный финальный XOR
            current_state = bytes([current_state[i] ^ round_keys[self.rounds][i] 
                                 for i in range(len(current_state))])
            
            # Обратные раунды
            for round_num in range(self.rounds - 1, -1, -1):
                # Обратная перестановка битов (кроме первого обратного раунда)
                if round_num < self.rounds - 1:
                    current_state = self._inverse_permute_bits(current_state)
                
                # Обратная замена байтов
                current_state = self._inverse_substitute_bytes(current_state)
                
                # XOR с ключом раунда
                current_state = bytes([current_state[i] ^ round_keys[round_num][i] 
                                     for i in range(len(current_state))])
            
            decrypted_blocks.append(current_state)
        
        return b''.join(decrypted_blocks)


class FeistelNetwork:
    def __init__(self, key, rounds=16):
        self.key = key
        self.rounds = rounds
        self.position = 0

    def _reset_position(self):
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def _f_function(self, right_block, round_key):
        block_bytes = right_block.to_bytes(4, 'big')
        mixed = bytes([block_bytes[i] ^ round_key[i % len(round_key)] for i in range(len(block_bytes))])
        result = hashlib.sha256(mixed).digest()
        return int.from_bytes(result[:4], 'big')

    def _split_blocks(self, data):
        blocks = []
        for i in range(0, len(data), 8):
            block = data[i:i+8]
            if len(block) < 8:
                block = block + b'\x00' * (8 - len(block))
            blocks.append(block)
        return blocks

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
            
        self._reset_position()
        blocks = self._split_blocks(data)
        encrypted_blocks = []
        
        for block in blocks:
            left = int.from_bytes(block[:4], 'big')
            right = int.from_bytes(block[4:], 'big')
            
            round_keys = self._key_stream(self.rounds * 4)
            
            for round_num in range(self.rounds):
                round_key = round_keys[round_num*4:(round_num+1)*4]
                temp = right
                f_result = self._f_function(right, round_key)
                right = left ^ f_result
                left = temp
            
            encrypted_block = left.to_bytes(4, 'big') + right.to_bytes(4, 'big')
            encrypted_blocks.append(encrypted_block)
        
        return b''.join(encrypted_blocks)

    def decrypt(self, encrypted_data):
        self._reset_position()
        blocks = self._split_blocks(encrypted_data)
        decrypted_blocks = []
        
        for block in blocks:
            left = int.from_bytes(block[:4], 'big')
            right = int.from_bytes(block[4:], 'big')
            
            round_keys = self._key_stream(self.rounds * 4)
            
            for round_num in range(self.rounds-1, -1, -1):
                round_key = round_keys[round_num*4:(round_num+1)*4]
                temp = left
                f_result = self._f_function(left, round_key)
                left = right ^ f_result
                right = temp
            
            decrypted_block = left.to_bytes(4, 'big') + right.to_bytes(4, 'big')
            decrypted_blocks.append(decrypted_block)
        
        return b''.join(decrypted_blocks)


class StreamCipher:
    def __init__(self, key):
        self.key = key
        self.position = 0

    def _reset_position(self):
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
        self._reset_position()
        key_stream = self._key_stream(len(data))
        encrypted = bytes([data[i] ^ key_stream[i] for i in range(len(data))])
        return encrypted

    def decrypt(self, encrypted_data):
        self._reset_position()
        return self.encrypt(encrypted_data)


def interactive_cipher():
    print("=== Сравнение алгоритмов шифрования ===")
    
    while True:
        print("\nВыберите алгоритм:")
        print("1. Поточный шифр (XOR)")
        print("2. Сеть Фейстеля (блочный)")
        print("3. SPN (Substitution-Permutation Network)")
        print("4. Тестирование всех алгоритмов")
        print("5. Выйти")
        
        algo_choice = input("Ваш выбор (1-5): ").strip()
        
        if algo_choice == '5':
            print("Выход...")
            break
        elif algo_choice == '4':
            test_all_algorithms()
            continue
        elif algo_choice not in ['1', '2', '3']:
            print("Неверный выбор алгоритма!")
            continue
            
        mode = input("Вы хотите зашифровать (e) или расшифровать (d)? ").strip().lower()
        
        if mode not in ['e', 'd']:
            print("Неверный выбор режима!")
            continue
            
        key_input = input("Введите ключ: ")
        if not key_input:
            print("Ключ не может быть пустым!")
            continue
        key = key_input.encode()
        
        if algo_choice == '1':
            cipher = StreamCipher(key)
            algo_name = "поточный шифр"
        elif algo_choice == '2':
            rounds_input = input("Введите количество раундов (по умолчанию 16): ").strip()
            rounds = int(rounds_input) if rounds_input else 16
            cipher = FeistelNetwork(key, rounds)
            algo_name = f"сеть Фейстеля ({rounds} раундов)"
        else:  # algo_choice == '3'
            rounds_input = input("Введите количество раундов (по умолчанию 4): ").strip()
            rounds = int(rounds_input) if rounds_input else 4
            cipher = SPN(key, rounds)
            algo_name = f"SPN ({rounds} раундов)"
        
        if mode == 'e':
            message = input("Введите сообщение для шифрования: ")
            if not message:
                print("Сообщение не может быть пустым!")
                continue
                
            print(f"\nШифруем с помощью {algo_name}...")
            encrypted = cipher.encrypt(message)
            print(f"Зашифрованное (hex): {encrypted.hex()}")
            print(f"Длина: {len(encrypted)} байт")
            
        else:  # mode == 'd'
            hex_data = input("Введите зашифрованный текст в hex: ").strip()
            if not hex_data:
                print("Данные не могут быть пустыми!")
                continue
                
            try:
                encrypted = bytes.fromhex(hex_data)
                print(f"\nДешифруем с помощью {algo_name}...")
                decrypted = cipher.decrypt(encrypted)
                
                # Убираем дополняющие нули для блочных шифров
                if algo_choice in ['2', '3']:
                    decrypted = decrypted.rstrip(b'\x00')
                
                print(f"Расшифрованное сообщение: {decrypted.decode(errors='replace')}")
                
            except ValueError as e:
                print(f"Ошибка: неверный hex формат! {e}")
            except Exception as e:
                print(f"Ошибка при дешифровании: {e}")


def test_all_algorithms():
    """Тестирование всех алгоритмов"""
    print("\n" + "="*50)
    print("ТЕСТИРОВАНИЕ ВСЕХ АЛГОРИТМОВ")
    print("="*50)
    
    message = input("Введите тестовое сообщение: ")
    if not message:
        print("Сообщение не может быть пустым!")
        return
        
    key_input = input("Введите ключ для теста (или нажмите Enter для ключа по умолчанию b'test_key'): ")
    key = key_input.encode() if key_input else b"test_key"
    
    print(f"\n--- Тестовые данные ---")
    print(f"Сообщение: '{message}'")
    print(f"Длина сообщения: {len(message)} байт")
    print(f"Ключ: {key}")
    
    algorithms = [
        ("Поточный шифр", StreamCipher(key)),
        ("Сеть Фейстеля (8 раундов)", FeistelNetwork(key, 8)),
        ("SPN (4 раунда)", SPN(key, 4))
    ]
    
    for algo_name, cipher in algorithms:
        print(f"\n--- {algo_name} ---")
        try:
            encrypted = cipher.encrypt(message)
            decrypted = cipher.decrypt(encrypted)
            
            # Убираем дополняющие нули для блочных шифров
            if algo_name != "Поточный шифр":
                decrypted = decrypted.rstrip(b'\x00')
            
            success = decrypted.decode() == message
            print(f"Результат: {'✓ УСПЕХ' if success else '✗ ОШИБКА'}")
            print(f"Зашифровано (первые 32 hex): {encrypted.hex()[:32]}...")
            print(f"Размер: {len(encrypted)} байт")
            
            if not success:
                print(f"Ожидалось: '{message}'")
                print(f"Получено: '{decrypted.decode(errors='replace')}'")
                
        except Exception as e:
            print(f"Результат: ✗ ОШИБКА: {e}")


if __name__ == "__main__":
    interactive_cipher()
