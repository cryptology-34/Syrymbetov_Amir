class SPN:
    def __init__(self, key):
        self.key = key
        self.feistel = FeistelCipher(key)
        self.hasher = SimpleHash(256)  # Добавляем хэш-функцию
        
        # S-блоки на основе хэш-функции
        self.s_box = self._generate_s_box()
        self.s_box_inv = {v: k for k, v in self.s_box.items()}
        
        # P-блок (простая перестановка)
        self.p_box = [3, 0, 2, 1, 7, 4, 6, 5]
    
    def _generate_s_box(self):
        """Генерация S-блока на основе хэш-функции"""
        s_box = {}
        for i in range(256):
            hash_val = self.hasher.hash(bytes([i]) + self.key)
            s_box[i] = hash_val[0]
        return s_box
    
    def _substitute(self, data):
        """S-блок подстановка"""
        return bytes([self.s_box[b] for b in data])
    
    def _substitute_inv(self, data):
        """Обратная S-блок подстановка"""
        return bytes([self.s_box_inv[b] for b in data])
    
    def _permute(self, data):
        """P-блок перестановка"""
        if len(data) != 8:
            raise ValueError("Data must be 8 bytes for permutation")
        result = bytearray(8)
        for i, pos in enumerate(self.p_box):
            result[i] = data[pos]
        return bytes(result)
    
    def _permute_inv(self, data):
        """Обратная P-блок перестановка"""
        if len(data) != 8:
            raise ValueError("Data must be 8 bytes for permutation")
        result = bytearray(8)
        for i, pos in enumerate(self.p_box):
            result[pos] = data[i]
        return bytes(result)
    
    def encrypt(self, data):
        """Шифрование SPN"""
        # Используем Фейстель для первого этапа
        feistel_result = self.feistel.encrypt_block(data)
        
        # Применяем S-блок
        substituted = self._substitute(feistel_result)
        
        # Применяем P-блок
        permuted = self._permute(substituted)
        
        return permuted
    
    def decrypt(self, data):
        """Дешифрование SPN"""
        # Обратная P-блок
        permuted_inv = self._permute_inv(data)
        
        # Обратная S-блок
        substituted_inv = self._substitute_inv(permuted_inv)
        
        # Дешифрование Фейстелем
        decrypted = self.feistel.decrypt_block(substituted_inv)
        
        return decrypted

def test_spn():
    print("=== Тестирование SPN ===")
    spn = SPN(b"spn_key")
    
    block = b"ABCDEFGH"  # 8-байтовый блок
    encrypted = spn.encrypt(block)
    decrypted = spn.decrypt(encrypted)
    
    print(f"Исходный блок: {block}")
    print(f"Зашифрованный: {encrypted.hex()}")
    print(f"Расшифрованный: {decrypted}")
    print()
