class StreamCipher:
    def __init__(self, key):
        self.key = key
        self.position = 0
    
    def _prng(self):
        # Псевдослучайный генератор на основе LFSR
        state = self.key + self.position
        while True:
            state = (state << 1) ^ (state >> 3)
            state &= 0xFFFFFFFF
            yield state & 0xFF
            self.position += 1
    
    def encrypt_decrypt(self, data):
        # Шифрование/дешифрование (XOR с ключевым потоком)
        generator = self._prng()
        result = bytearray()
        
        for byte in data:
            key_byte = next(generator)
            result.append(byte ^ key_byte)
        return bytes(result)
    
    def encrypt_text(self, text):
        # Шифрование текста
        text_bytes = text.encode('utf-8')
        encrypted_bytes = self.encrypt_decrypt(text_bytes)
        return encrypted_bytes.hex()
    
    def decrypt_text(self, hex_string):
        # Дешифрование текста
        encrypted_bytes = bytes.fromhex(hex_string)
        decrypted_bytes = self.encrypt_decrypt(encrypted_bytes)
        return decrypted_bytes.decode('utf-8')

# Пример использования
if __name__ == "__main__":
    cipher = StreamCipher(key=0xABCD1234)
    message = "Реальность — иллюзия, Вселенная — голограмма, скупай золото!"
    
    print("Поточное шифрование:")
    print(f"Исходное: {message}")
    
    encrypted_hex = cipher.encrypt_text(message)
    print(f"Зашифровано (hex): {encrypted_hex}")    
    # Создаем новый объект для дешифрования (сброс позиции)
    cipher2 = StreamCipher(key=0xABCD1234)
    decrypted = cipher2.decrypt_text(encrypted_hex)
    print(f"Расшифровано: {decrypted}")
    print(f"Совпадает: {message == decrypted}")
    print()
