import hashlib
import os
import struct
import secrets
from typing import Union

# ==================== –•–ï–®-–§–£–ù–ö–¶–ò–ò ====================

class SHA256:
    def __init__(self):
        self.h = [
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
            0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
        ]
        
        self.k = [
            0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
            0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
            0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
            0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
            0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
            0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
            0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
            0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
        ]
        
    def _rotr(self, n, x):
        return ((x >> n) | (x << (32 - n))) & 0xFFFFFFFF
    
    def _shr(self, n, x):
        return (x >> n) & 0xFFFFFFFF
    
    def _ch(self, x, y, z):
        return (x & y) ^ (~x & z)
    
    def _maj(self, x, y, z):
        return (x & y) ^ (x & z) ^ (y & z)
    
    def _sigma0(self, x):
        return self._rotr(2, x) ^ self._rotr(13, x) ^ self._rotr(22, x)
    
    def _sigma1(self, x):
        return self._rotr(6, x) ^ self._rotr(11, x) ^ self._rotr(25, x)
    
    def _gamma0(self, x):
        return self._rotr(7, x) ^ self._rotr(18, x) ^ self._shr(3, x)
    
    def _gamma1(self, x):
        return self._rotr(17, x) ^ self._rotr(19, x) ^ self._shr(10, x)
    
    def _pad_message(self, message):
        if isinstance(message, str):
            message = message.encode('utf-8')
        
        length = len(message) * 8
        message += b'\x80'
        
        while (len(message) * 8) % 512 != 448:
            message += b'\x00'
        
        message += struct.pack('>Q', length)
        return message
    
    def _process_block(self, block):
        if len(block) != 64:
            raise ValueError("Block must be exactly 64 bytes (512 bits)")
            
        w = list(struct.unpack('>16I', block))
        
        for i in range(16, 64):
            s0 = self._gamma0(w[i-15])
            s1 = self._gamma1(w[i-2])
            w.append((w[i-16] + s0 + w[i-7] + s1) & 0xFFFFFFFF)
        
        a, b, c, d, e, f, g, h = self.h
        
        for i in range(64):
            s1 = self._sigma1(e)
            ch = self._ch(e, f, g)
            temp1 = (h + s1 + ch + self.k[i] + w[i]) & 0xFFFFFFFF
            s0 = self._sigma0(a)
            maj = self._maj(a, b, c)
            temp2 = (s0 + maj) & 0xFFFFFFFF
            
            h = g
            g = f
            f = e
            e = (d + temp1) & 0xFFFFFFFF
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & 0xFFFFFFFF
        
        self.h[0] = (self.h[0] + a) & 0xFFFFFFFF
        self.h[1] = (self.h[1] + b) & 0xFFFFFFFF
        self.h[2] = (self.h[2] + c) & 0xFFFFFFFF
        self.h[3] = (self.h[3] + d) & 0xFFFFFFFF
        self.h[4] = (self.h[4] + e) & 0xFFFFFFFF
        self.h[5] = (self.h[5] + f) & 0xFFFFFFFF
        self.h[6] = (self.h[6] + g) & 0xFFFFFFFF
        self.h[7] = (self.h[7] + h) & 0xFFFFFFFF
    
    def hash(self, data):
        if isinstance(data, str):
            data = data.encode('utf-8')
        
        self.h = [
            0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
            0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
        ]
        
        padded_data = self._pad_message(data)
        
        for i in range(0, len(padded_data), 64):
            block = padded_data[i:i+64]
            if len(block) == 64:
                self._process_block(block)
        
        return b''.join(struct.pack('>I', h) for h in self.h)
    
    def hexdigest(self, data):
        return self.hash(data).hex()

class SimpleHash:
    def __init__(self, output_bits=256):
        self.output_bits = output_bits
        self.output_bytes = output_bits // 8
        
    def hash(self, data):
        if isinstance(data, str):
            data = data.encode()
        hash_val = bytearray(b'\x00' * self.output_bytes)
        for i in range(0, len(data), self.output_bytes):
            block = data[i:i + self.output_bytes]
            block = block.ljust(self.output_bytes, b'\x00')
            for j in range(self.output_bytes):
                hash_val[j] ^= block[j]
                hash_val[j] = ((hash_val[j] << 3) | (hash_val[j] >> 5)) & 0xFF
        for _ in range(3):
            for j in range(self.output_bytes):
                hash_val[j] = (hash_val[j] + hash_val[(j + 1) % self.output_bytes]) & 0xFF
                hash_val[j] = ((hash_val[j] << 5) | (hash_val[j] >> 3)) & 0xFF
        return bytes(hash_val)

# ==================== –†–ï–ñ–ò–ú–´ –®–ò–§–†–û–í–ê–ù–ò–Ø ====================

class CBCMode:
    """–†–µ–∂–∏–º CBC (Cipher Block Chaining)"""
    
    def __init__(self, cipher, iv=None):
        self.cipher = cipher
        self.block_size = getattr(cipher, 'block_size', 16)
        self.iv = iv or os.urandom(self.block_size)
    
    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
            
        padding_length = self.block_size - (len(data) % self.block_size)
        if padding_length == 0:
            padding_length = self.block_size
        data = data + bytes([padding_length] * padding_length)
        
        blocks = [data[i:i + self.block_size] for i in range(0, len(data), self.block_size)]
        encrypted_blocks = []
        prev_block = self.iv
        
        for block in blocks:
            xored = bytes([block[i] ^ prev_block[i] for i in range(self.block_size)])
            encrypted_block = self.cipher.encrypt(xored)
            encrypted_blocks.append(encrypted_block)
            prev_block = encrypted_block
        
        return self.iv + b''.join(encrypted_blocks)
    
    def decrypt(self, encrypted_data):
        iv = encrypted_data[:self.block_size]
        encrypted_blocks = [encrypted_data[i:i + self.block_size] 
                          for i in range(self.block_size, len(encrypted_data), self.block_size)]
        
        decrypted_blocks = []
        prev_block = iv
        
        for block in encrypted_blocks:
            decrypted_block = self.cipher.decrypt(block)
            xored = bytes([decrypted_block[i] ^ prev_block[i] for i in range(self.block_size)])
            decrypted_blocks.append(xored)
            prev_block = block
        
        result = b''.join(decrypted_blocks)
        padding_length = result[-1]
        if padding_length <= self.block_size:
            return result[:-padding_length]
        return result

class CTRMode:
    """–†–µ–∂–∏–º CTR (Counter) - –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –±–ª–æ—á–Ω—ã–π —à–∏—Ñ—Ä –≤ –ø–æ—Ç–æ—á–Ω—ã–π"""
    
    def __init__(self, cipher, nonce=None):
        self.cipher = cipher
        self.block_size = getattr(cipher, 'block_size', 16)
        self.nonce = nonce or os.urandom(8)
    
    def _generate_keystream(self, length):
        keystream = b''
        counter = 0
        
        while len(keystream) < length:
            counter_block = self.nonce + counter.to_bytes(8, 'big')
            encrypted_counter = self.cipher.encrypt(counter_block)
            keystream += encrypted_counter
            counter += 1
        
        return keystream[:length]
    
    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
            
        keystream = self._generate_keystream(len(data))
        encrypted = bytes([data[i] ^ keystream[i] for i in range(len(data))])
        
        return self.nonce + encrypted
    
    def decrypt(self, encrypted_data):
        nonce = encrypted_data[:8]
        data = encrypted_data[8:]
        
        keystream = self._generate_keystream(len(data))
        decrypted = bytes([data[i] ^ keystream[i] for i in range(len(data))])
        
        return decrypted

# ==================== –®–ò–§–†–´ ====================

class StreamCipher:
    def __init__(self, key):
        self.key = key
        self.position = 0

    def _reset_position(self):
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
        self._reset_position()
        key_stream = self._key_stream(len(data))
        encrypted = bytes([data[i] ^ key_stream[i] for i in range(len(data))])
        return encrypted

    def decrypt(self, encrypted_data):
        self._reset_position()
        return self.encrypt(encrypted_data)

class FeistelNetwork:
    def __init__(self, key, rounds=16):
        self.key = key
        self.rounds = rounds
        self.position = 0
        self.block_size = 16  # 128 –±–∏—Ç

    def _reset_position(self):
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def _f_function(self, right_block, round_key):
        block_bytes = right_block.to_bytes(8, 'big')
        mixed = bytes([block_bytes[i] ^ round_key[i % len(round_key)] for i in range(len(block_bytes))])
        result = hashlib.sha256(mixed).digest()
        return int.from_bytes(result[:8], 'big')

    def _split_blocks(self, data):
        blocks = []
        for i in range(0, len(data), self.block_size):
            block = data[i:i + self.block_size]
            if len(block) < self.block_size:
                block = block + b'\x00' * (self.block_size - len(block))
            blocks.append(block)
        return blocks

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
            
        self._reset_position()
        blocks = self._split_blocks(data)
        encrypted_blocks = []
        
        for block in blocks:
            left = int.from_bytes(block[:8], 'big')
            right = int.from_bytes(block[8:], 'big')
            
            round_keys = self._key_stream(self.rounds * 8)
            
            for round_num in range(self.rounds):
                round_key = round_keys[round_num*8:(round_num+1)*8]
                temp = right
                f_result = self._f_function(right, round_key)
                right = left ^ f_result
                left = temp
            
            encrypted_block = left.to_bytes(8, 'big') + right.to_bytes(8, 'big')
            encrypted_blocks.append(encrypted_block)
        
        return b''.join(encrypted_blocks)

    def decrypt(self, encrypted_data):
        self._reset_position()
        blocks = self._split_blocks(encrypted_data)
        decrypted_blocks = []
        
        for block in blocks:
            left = int.from_bytes(block[:8], 'big')
            right = int.from_bytes(block[8:], 'big')
            
            round_keys = self._key_stream(self.rounds * 8)
            
            for round_num in range(self.rounds-1, -1, -1):
                round_key = round_keys[round_num*8:(round_num+1)*8]
                temp = left
                f_result = self._f_function(left, round_key)
                left = right ^ f_result
                right = temp
            
            decrypted_block = left.to_bytes(8, 'big') + right.to_bytes(8, 'big')
            decrypted_blocks.append(decrypted_block)
        
        result = b''.join(decrypted_blocks)
        return result.rstrip(b'\x00')

class SPN:
    def __init__(self, key, rounds=10, block_size=16):
        self.key = key
        self.rounds = rounds
        self.block_size = block_size
        self.position = 0

    def _reset_position(self):
        self.position = 0

    def _key_stream(self, length):
        result = b''
        while len(result) < length:
            data = self.key + str(self.position).encode()
            hash_val = hashlib.sha256(data).digest()
            result += hash_val
            self.position += 1
        return result[:length]

    def _generate_round_keys(self):
        total_keys_needed = (self.rounds + 1) * self.block_size
        key_material = self._key_stream(total_keys_needed)
        
        round_keys = []
        for i in range(self.rounds + 1):
            start = i * self.block_size
            end = start + self.block_size
            round_keys.append(key_material[start:end])
        
        return round_keys

    def _s_box(self, byte):
        s_box_data = hashlib.sha256(b's_box_' + bytes([byte])).digest()
        return s_box_data[0]

    def _inverse_s_box(self, byte):
        for i in range(256):
            if self._s_box(i) == byte:
                return i
        return byte

    def _substitute_bytes(self, data):
        return bytes([self._s_box(b) for b in data])

    def _inverse_substitute_bytes(self, data):
        return bytes([self._inverse_s_box(b) for b in data])

    def _permute_bits(self, data):
        bits = []
        for byte in data:
            bits.extend([(byte >> i) & 1 for i in range(7, -1, -1)])
        
        permuted_bits = bits[32:] + bits[:32]
        
        result = bytearray()
        for i in range(0, len(permuted_bits), 8):
            byte = 0
            for j in range(8):
                if i + j < len(permuted_bits):
                    byte = (byte << 1) | permuted_bits[i + j]
            result.append(byte)
        
        return bytes(result)

    def _inverse_permute_bits(self, data):
        bits = []
        for byte in data:
            bits.extend([(byte >> i) & 1 for i in range(7, -1, -1)])
        
        inverse_permuted_bits = bits[-32:] + bits[:-32]
        
        result = bytearray()
        for i in range(0, len(inverse_permuted_bits), 8):
            byte = 0
            for j in range(8):
                if i + j < len(inverse_permuted_bits):
                    byte = (byte << 1) | inverse_permuted_bits[i + j]
            result.append(byte)
        
        return bytes(result)

    def _split_blocks(self, data):
        blocks = []
        for i in range(0, len(data), self.block_size):
            block = data[i:i + self.block_size]
            if len(block) < self.block_size:
                block = block + b'\x00' * (self.block_size - len(block))
            blocks.append(block)
        return blocks

    def encrypt(self, data):
        if isinstance(data, str):
            data = data.encode()
            
        self._reset_position()
        round_keys = self._generate_round_keys()
        blocks = self._split_blocks(data)
        encrypted_blocks = []
        
        for block in blocks:
            current_state = block
            
            for round_num in range(self.rounds):
                current_state = bytes([current_state[i] ^ round_keys[round_num][i] 
                                     for i in range(len(current_state))])
                
                current_state = self._substitute_bytes(current_state)
                
                if round_num < self.rounds - 1:
                    current_state = self._permute_bits(current_state)
            
            current_state = bytes([current_state[i] ^ round_keys[self.rounds][i] 
                                 for i in range(len(current_state))])
            
            encrypted_blocks.append(current_state)
        
        return b''.join(encrypted_blocks)

    def decrypt(self, encrypted_data):
        self._reset_position()
        round_keys = self._generate_round_keys()
        blocks = self._split_blocks(encrypted_data)
        decrypted_blocks = []
        
        for block in blocks:
            current_state = block
            
            current_state = bytes([current_state[i] ^ round_keys[self.rounds][i] 
                                 for i in range(len(current_state))])
            
            for round_num in range(self.rounds - 1, -1, -1):
                if round_num < self.rounds - 1:
                    current_state = self._inverse_permute_bits(current_state)
                
                current_state = self._inverse_substitute_bytes(current_state)
                
                current_state = bytes([current_state[i] ^ round_keys[round_num][i] 
                                     for i in range(len(current_state))])
            
            decrypted_blocks.append(current_state)
        
        result = b''.join(decrypted_blocks)
        return result.rstrip(b'\x00')

# ==================== –≠–¶–ü ====================

class EllipticCurve:
    def __init__(self):
        self.p = 2**255 - 19
        self.a = -1
        self.b = 0
        self.G = (9, 14781619447589544791020593568409986887264606134616475288964881837755586237401)
        self.n = 2**252 + 27742317777372353535851937790883648493
    
    def mod_inverse(self, a, p):
        return pow(a, p-2, p)
    
    def point_add(self, P1, P2):
        if P1 is None:
            return P2
        if P2 is None:
            return P1
            
        x1, y1 = P1
        x2, y2 = P2
        
        if x1 == x2:
            if y1 == y2:
                s = (3 * x1 * x1 + self.a) * self.mod_inverse(2 * y1, self.p) % self.p
            else:
                return None
        else:
            s = (y2 - y1) * self.mod_inverse(x2 - x1, self.p) % self.p
        
        x3 = (s * s - x1 - x2) % self.p
        y3 = (s * (x1 - x3) - y1) % self.p
        
        return (x3, y3)
    
    def point_multiply(self, k, P):
        if k == 0:
            return None
        if k == 1:
            return P
            
        result = None
        addend = P
        
        while k:
            if k & 1:
                result = self.point_add(result, addend)
            addend = self.point_add(addend, addend)
            k >>= 1
            
        return result

class DigitalSignature:
    def __init__(self):
        self.curve = EllipticCurve()
        self.sha256 = SHA256()
    
    def generate_key_pair(self):
        private_key = secrets.randbelow(self.curve.n - 1) + 1
        public_key = self.curve.point_multiply(private_key, self.curve.G)
        return private_key, public_key
    
    def sign(self, message, private_key):
        message_hash = int.from_bytes(self.sha256.hash(message), byteorder='big')
        message_hash = message_hash % self.curve.n
        
        while True:
            k = secrets.randbelow(self.curve.n - 1) + 1
            R = self.curve.point_multiply(k, self.curve.G)
            if R is None:
                continue
                
            r = R[0] % self.curve.n
            if r == 0:
                continue
            
            k_inv = self.curve.mod_inverse(k, self.curve.n)
            s = (k_inv * (message_hash + r * private_key)) % self.curve.n
            
            if s != 0:
                break
        
        return (r, s)
    
    def verify(self, message, signature, public_key):
        r, s = signature
        
        if not (1 <= r < self.curve.n and 1 <= s < self.curve.n):
            return False
        
        message_hash = int.from_bytes(self.sha256.hash(message), byteorder='big')
        message_hash = message_hash % self.curve.n
        
        w = self.curve.mod_inverse(s, self.curve.n)
        u1 = (message_hash * w) % self.curve.n
        u2 = (r * w) % self.curve.n
        
        X1 = self.curve.point_multiply(u1, self.curve.G)
        X2 = self.curve.point_multiply(u2, public_key)
        X = self.curve.point_add(X1, X2)
        
        if X is None:
            return False
        
        return (X[0] % self.curve.n) == r
    
    def signature_to_string(self, signature):
        r, s = signature
        return f"{r:064x}{s:064x}"
    
    def string_to_signature(self, sig_str):
        if len(sig_str) != 128:
            raise ValueError("Invalid signature string length")
        r = int(sig_str[:64], 16)
        s = int(sig_str[64:], 16)
        return (r, s)
    
    def public_key_to_string(self, public_key):
        x, y = public_key
        return f"{x:064x}{y:064x}"
    
    def string_to_public_key(self, key_str):
        if len(key_str) != 128:
            raise ValueError("Invalid public key string length")
        x = int(key_str[:64], 16)
        y = int(key_str[64:], 16)
        return (x, y)

# ==================== –ò–ù–¢–ï–†–ê–ö–¢–ò–í–ù–´–ô –ò–ù–¢–ï–†–§–ï–ô–° ====================

def cipher_menu(cipher_class, cipher_name, supports_modes=True):
    """–ú–µ–Ω—é –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —à–∏—Ñ—Ä–æ–º"""
    
    print(f"\n--- {cipher_name.upper()} ---")
    
    # –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ –¥–ª—è –±–ª–æ—á–Ω—ã—Ö —à–∏—Ñ—Ä–æ–≤
    mode = None
    mode_name = ""
    
    if supports_modes:
        print("\nüìä –í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:")
        print("1. –ë–∞–∑–æ–≤—ã–π (–±–µ–∑ —Ä–µ–∂–∏–º–∞)")
        print("2. CBC (Cipher Block Chaining)")
        print("3. CTR (Counter)")
        
        mode_choice = input("–í–∞—à –≤—ã–±–æ—Ä (1-3): ").strip()
        
        if mode_choice == '2':
            mode = CBCMode
            mode_name = " + CBC"
        elif mode_choice == '3':
            mode = CTRMode
            mode_name = " + CTR"
        else:
            mode_name = " (–±–∞–∑–æ–≤—ã–π)"
    
    # –í–≤–æ–¥ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    key = input("–í–≤–µ–¥–∏—Ç–µ –∫–ª—é—á: ").encode()
    if not key:
        print("‚ùå –ö–ª—é—á –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º!")
        return
    
    # –ù–ê–°–¢–†–û–ô–ö–ê –ü–ê–†–ê–ú–ï–¢–†–û–í –®–ò–§–†–ê
    base_cipher = None
    
    if cipher_class == StreamCipher:
        base_cipher = StreamCipher(key)
        full_name = f"–ü–æ—Ç–æ—á–Ω—ã–π —à–∏—Ñ—Ä{mode_name}"
    
    elif cipher_class == FeistelNetwork:
        rounds = int(input("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 16): ") or 16)
        base_cipher = FeistelNetwork(key, rounds)
        full_name = f"–°–µ—Ç—å –§–µ–π—Å—Ç–µ–ª—è ({rounds} —Ä–∞—É–Ω–¥–æ–≤){mode_name}"
    
    elif cipher_class == SPN:
        rounds = int(input("–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞—É–Ω–¥–æ–≤ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10): ") or 10)
        base_cipher = SPN(key, rounds)
        full_name = f"SPN ({rounds} —Ä–∞—É–Ω–¥–æ–≤){mode_name}"
    
    else:
        print("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–ª–∞—Å—Å —à–∏—Ñ—Ä–∞!")
        return
    
    # –°–æ–∑–¥–∞–Ω–∏–µ —à–∏—Ñ—Ä–∞ —Å —Ä–µ–∂–∏–º–æ–º (–¥–ª—è –±–ª–æ—á–Ω—ã—Ö —à–∏—Ñ—Ä–æ–≤)
    if supports_modes and mode:
        cipher = mode(base_cipher)
    else:
        cipher = base_cipher
    
    # –í—ã–±–æ—Ä –æ–ø–µ—Ä–∞—Ü–∏–∏
    operation = input("–®–∏—Ñ—Ä–æ–≤–∞—Ç—å (e) –∏–ª–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å (d)? ").strip().lower()
    
    if operation == 'e':
        message = input("–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ")
        if not message:
            print("‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º!")
            return
        
        try:
            encrypted = cipher.encrypt(message)
            print(f"\n‚úÖ –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ —Å –ø–æ–º–æ—â—å—é {full_name}")
            print(f"üìä –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ (hex): {encrypted.hex()}")
            print(f"üìè –†–∞–∑–º–µ—Ä: {len(encrypted)} –±–∞–π—Ç")
            
            # –î–ª—è —Ä–µ–∂–∏–º–æ–≤ —Å IV/nonce –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏—Ö
            if hasattr(cipher, 'iv') and cipher.iv:
                print(f"üîë IV: {cipher.iv.hex()}")
            elif hasattr(cipher, 'nonce') and cipher.nonce:
                print(f"üîë Nonce: {cipher.nonce.hex()}")
                
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: {e}")
    
    elif operation == 'd':
        hex_data = input("–í–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ hex: ").strip()
        if not hex_data:
            print("‚ùå –î–∞–Ω–Ω—ã–µ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º–∏!")
            return
        
        try:
            encrypted = bytes.fromhex(hex_data)
            decrypted = cipher.decrypt(encrypted)
            print(f"\n‚úÖ –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ —Å –ø–æ–º–æ—â—å—é {full_name}")
            print(f"üìù –°–æ–æ–±—â–µ–Ω–∏–µ: {decrypted.decode(errors='replace')}")
            
        except ValueError:
            print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π hex —Ñ–æ—Ä–º–∞—Ç!")
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: {e}")
    
    else:
        print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä –æ–ø–µ—Ä–∞—Ü–∏–∏!")

def hash_menu():
    """–ú–µ–Ω—é –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ö–µ—à-—Ñ—É–Ω–∫—Ü–∏—è–º–∏"""
    
    sha = SHA256()
    
    while True:
        print("\n" + "="*50)
        print("#Ô∏è‚É£ –•–ï–®-–§–£–ù–ö–¶–ò–ò")
        print("="*50)
        print("1. üßÆ –í—ã—á–∏—Å–ª–∏—Ç—å —Ö–µ—à SHA-256")
        print("2. üîç –°—Ä–∞–≤–Ω–∏—Ç—å —Å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º hashlib.sha256")
        print("3. ‚Ü©Ô∏è –ù–∞–∑–∞–¥")
        
        choice = input("\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ (1-3): ").strip()
        
        if choice == '3':
            break
        elif choice == '1':
            data = input("–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è: ")
            custom_hash = sha.hexdigest(data)
            builtin_hash = hashlib.sha256(data.encode()).hexdigest()
            
            print(f"\nüî¢ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è SHA-256: {custom_hash}")
            print(f"üî¢ –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π SHA-256:  {builtin_hash}")
            print(f"‚úÖ –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ: {custom_hash == builtin_hash}")
            
        elif choice == '2':
            test_vectors = [
                "",
                "abc", 
                "Hello, World!",
                "SHA-256 test",
                "a" * 100,
                "–¢–µ—Å—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º"
            ]
            
            print("\nüîç –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –≤–µ–∫—Ç–æ—Ä–∞–º–∏:")
            print("=" * 60)
            
            all_match = True
            for test in test_vectors:
                sha_custom = SHA256()
                custom = sha_custom.hexdigest(test)
                builtin = hashlib.sha256(test.encode()).hexdigest()
                match = custom == builtin
                status = "‚úÖ" if match else "‚ùå"
                
                print(f"{status} '{test[:20]}{'...' if len(test) > 20 else ''}'")
                if not match:
                    print(f"  Custom:  {custom}")
                    print(f"  Builtin: {builtin}")
                    all_match = False
            
            if all_match:
                print("\nüéâ –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ–π–¥–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ!")
            else:
                print("\n‚ö†Ô∏è  –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ—à–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É")

def digital_signature_menu():
    """–ú–µ–Ω—é —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–æ–π –ø–æ–¥–ø–∏—Å–∏"""
    
    dsa = DigitalSignature()
    private_key = None
    public_key = None
    
    while True:
        print("\n" + "="*50)
        print("üìù –≠–õ–ï–ö–¢–†–û–ù–ù–ê–Ø –ü–û–î–ü–ò–°–¨ (ECDSA)")
        print("="*50)
        print("1. üîë –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—É –∫–ª—é—á–µ–π")
        print("2. ‚úçÔ∏è –ü–æ–¥–ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ")
        print("3. ‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å—å")
        print("4. üíæ –≠–∫—Å–ø–æ—Ä—Ç/–∏–º–ø–æ—Ä—Ç –∫–ª—é—á–µ–π")
        print("5. ‚Ü©Ô∏è –ù–∞–∑–∞–¥")
        
        choice = input("\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ (1-5): ").strip()
        
        if choice == '5':
            break
        elif choice == '1':
            private_key, public_key = dsa.generate_key_pair()
            print(f"\n‚úÖ –ü–∞—Ä–∞ –∫–ª—é—á–µ–π —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∞!")
            print(f"üîê –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á: {private_key:064x}")
            print(f"üîë –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á: {dsa.public_key_to_string(public_key)}")
            
        elif choice == '2':
            if private_key is None:
                print("‚ùå –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –ø–∞—Ä—É –∫–ª—é—á–µ–π!")
                continue
                
            message = input("–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–¥–ø–∏—Å–∏: ")
            signature = dsa.sign(message, private_key)
            signature_str = dsa.signature_to_string(signature)
            
            print(f"\n‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∞–Ω–æ!")
            print(f"üìù –°–æ–æ–±—â–µ–Ω–∏–µ: '{message}'")
            print(f"üñäÔ∏è –ü–æ–¥–ø–∏—Å—å: {signature_str}")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å—å –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
            is_valid = dsa.verify(message, signature, public_key)
            print(f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏: {'‚úÖ –í–ê–õ–ò–î–ù–ê' if is_valid else '‚ùå –ù–ï–í–ê–õ–ò–î–ù–ê'}")
            
        elif choice == '3':
            if public_key is None:
                print("‚ùå –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∏–ª–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á!")
                continue
                
            message = input("–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏: ")
            signature_str = input("–í–≤–µ–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å—å (hex): ").strip()
            
            try:
                signature = dsa.string_to_signature(signature_str)
                is_valid = dsa.verify(message, signature, public_key)
                
                print(f"\nüîç –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏: {'‚úÖ –ü–û–î–ü–ò–°–¨ –í–ê–õ–ò–î–ù–ê' if is_valid else '‚ùå –ü–û–î–ü–ò–°–¨ –ù–ï–í–ê–õ–ò–î–ù–ê'}")
                print(f"üìù –°–æ–æ–±—â–µ–Ω–∏–µ: '{message}'")
                print(f"üîë –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á: {dsa.public_key_to_string(public_key)[:32]}...")
                
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ–¥–ø–∏—Å–∏: {e}")
                
        elif choice == '4':
            print("\n1. –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á–∏")
            print("2. –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á")
            print("3. –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á")
            
            sub_choice = input("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ (1-3): ").strip()
            
            if sub_choice == '1':
                if private_key is None or public_key is None:
                    print("‚ùå –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –ø–∞—Ä—É –∫–ª—é—á–µ–π!")
                    continue
                    
                print(f"\nüîê –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á: {private_key:064x}")
                print(f"üîë –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á: {dsa.public_key_to
